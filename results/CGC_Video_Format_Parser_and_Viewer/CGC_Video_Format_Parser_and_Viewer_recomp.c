#include <stddef.h>

#include "defs.h"
// Auto-generated code for recompilation of target [CGC_Video_Format_Parser_and_Viewer]



typedef unsigned int cgc_size_t;
typedef struct MALLOC_ALLOC_HDR{  cgc_size_t alloc_size;} MALLOC_ALLOC_HDR;
typedef MALLOC_ALLOC_HDR tMallocAllocHdr;
typedef struct MALLOC_ALLOC_FTR{  struct MALLOC_ALLOC_HDR *pNext;  struct MALLOC_ALLOC_HDR *pPrev;} MALLOC_ALLOC_FTR;
typedef MALLOC_ALLOC_FTR tMallocAllocFtr;
typedef struct MALLOC_MANAGER{  void *pFreeList;} MALLOC_MANAGER;
typedef MALLOC_MANAGER tMallocManager;
typedef char *__gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef unsigned char uchar_t;
typedef unsigned int uint_t;
typedef struct BitStream{  char *stream;  unsigned int streamLength;  unsigned int byteIndex;  unsigned int bitIndex;} BitStream;
typedef BitStream *pBitStream;
typedef struct frame{  unsigned int height;  unsigned int width;  char *image;} frame;
typedef frame *pframe;
typedef struct pixelDict{  unsigned int charCount;  char *pixelArray;} pixelDict;
typedef pixelDict pixelDict_0;
typedef pixelDict *ppixelDict;
typedef struct cvf{  unsigned int height;  unsigned int width;  unsigned int frameCount;  char name[256];  char desc[256];  pixelDict_0 pds[8];  unsigned int rCount;  pframe *renderedFrames;} cvf;
typedef cvf *pcvf;
void __prd_init() {
}
void __prd_exit() {
}
/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/



//-------------------------------------------------------------------------
// Function declarations

typedef void * (*pcgc_malloc)(cgc_size_t);
pcgc_malloc cgc_malloc = NULL;

typedef void (*pcgc_free)(void *);
pcgc_free cgc_free = NULL;

typedef int (*pcgc_printf)(const char *, ...);
pcgc_printf cgc_printf = NULL;

typedef void * (*pcgc_memcpy)(void *, void *, cgc_size_t);
pcgc_memcpy cgc_memcpy = NULL;

typedef void * (*pcgc_memset)(void *, int, cgc_size_t);
pcgc_memset cgc_memset = NULL;

typedef int (*pcgc_readBits)(pBitStream, unsigned int, unsigned int *);
pcgc_readBits cgc_readBits = NULL;

typedef unsigned int (*pcgc_bitsNeeded)(unsigned int);
pcgc_bitsNeeded cgc_bitsNeeded = NULL;

int  mycgc_parseCVFFrame(pBitStream pbs, pcvf pNewImage);


//----- (000025D5) --------------------------------------------------------
int  mycgc_parseCVFFrame(pBitStream pbs, pcvf pNewImage)
{
  int result; // eax
  char *v3; // eax
  unsigned int pixel_count; // [esp+4h] [ebp-44h] BYREF
  unsigned int ybits; // [esp+8h] [ebp-40h] BYREF
  unsigned int xbits; // [esp+Ch] [ebp-3Ch] BYREF
  pixelDict_0 standard_dictionary; // [esp+10h] [ebp-38h] BYREF
  unsigned int flag; // [esp+18h] [ebp-30h] BYREF
  unsigned int pixel_bits; // [esp+1Ch] [ebp-2Ch]
  unsigned int index; // [esp+20h] [ebp-28h]
  unsigned int length; // [esp+24h] [ebp-24h]
  pframe newFrame; // [esp+28h] [ebp-20h]
  unsigned char custom_dict; // [esp+2Ch] [ebp-1Ch]
  unsigned char pixel_dict; // [esp+2Dh] [ebp-1Bh]
  unsigned char index_type; // [esp+2Eh] [ebp-1Ah]
  unsigned char frame_type; // [esp+2Fh] [ebp-19h]
  int i; // [esp+30h] [ebp-18h]
  unsigned int pixel_count_bits; // [esp+34h] [ebp-14h]
  unsigned int pixel_index_length; // [esp+38h] [ebp-10h]
  ppixelDict dictionary; // [esp+3Ch] [ebp-Ch]

  flag = 0;
  frame_type = 0;
  index_type = 0;
  pixel_dict = 0;
  custom_dict = 0;
  newFrame = 0;
  dictionary = 0;
  length = 0;
  index = 0;
  xbits = 0;
  ybits = 0;
  pixel_index_length = 0;
  pixel_count = 0;
  pixel_count_bits = 0;
  pixel_bits = 0;
  if ( !pbs )
    return 0;
  if ( !pNewImage )
    return 0;
  if ( !pNewImage->height )
  {
    cgc_printf("[ERROR] Header must be specified prior to frame rendering.\n");
    return 0;
  }
  if ( !cgc_readBits(pbs, 8u, &flag) )
    return 0;
  frame_type = (flag & 0x80) != 0;
  index_type = (flag & 0x40) != 0;
  pixel_dict = (flag >> 3) & 7;
  custom_dict = flag & 7;
  if ( !pNewImage->rCount && frame_type )
  {
    cgc_printf("[ERROR] First frame must be full\n");
    return 0;
  }
  if ( pixel_dict )
  {
    if ( pixel_dict == 1 )
    {
      standard_dictionary.charCount = 2;
      standard_dictionary.pixelArray = " .";
      dictionary = &standard_dictionary;
    }
    else if ( pixel_dict == 2 )
    {
      standard_dictionary.charCount = 4;
      standard_dictionary.pixelArray = " .|#";
      dictionary = &standard_dictionary;
    }
    else if ( pixel_dict == 3 )
    {
      standard_dictionary.charCount = 8;
      standard_dictionary.pixelArray = " .|#@$()";
      dictionary = &standard_dictionary;
    }
    else if ( pixel_dict == 4 )
    {
      standard_dictionary.charCount = 16;
      standard_dictionary.pixelArray = " .|#@$()*HOEWM%&";
      dictionary = &standard_dictionary;
    }
    else if ( pixel_dict == 5 )
    {
      standard_dictionary.charCount = 42;
      standard_dictionary.pixelArray = " .|#@$()*HOEWM%&abcdefghijklmnopqrstuvwxyz";
      dictionary = &standard_dictionary;
    }
    else
    {
      if ( pixel_dict == 6 )
      {
        standard_dictionary.charCount = 62;
        standard_dictionary.pixelArray = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      }
      else
      {
        standard_dictionary.charCount = 95;
        standard_dictionary.pixelArray = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijkl"
                                         "mnopqrstuvwxyz{|}~";
      }
      dictionary = &standard_dictionary;
    }
  }
  else
  {
    if ( !pNewImage->pds[custom_dict].charCount )
    {
      cgc_printf("[ERROR] Custom Dictionary $d does not exist\n", pixel_dict);
      return 0;
    }
    dictionary = &pNewImage->pds[custom_dict];
  }
  pixel_bits = cgc_bitsNeeded(dictionary->charCount - 1);
  newFrame = (pframe)cgc_malloc(0xCu);
  if ( !newFrame )
    return 0;
  length = pNewImage->height * pNewImage->width;
  newFrame->height = pNewImage->height;
  newFrame->width = pNewImage->width;
  v3 = (char *)cgc_malloc(length);
  newFrame->image = v3;
  if ( !newFrame->image )
  {
    cgc_free(newFrame);
    newFrame = 0;
    return 0;
  }
  if ( frame_type == 1 )
  {
    pixel_count = 0;
    pixel_index_length = cgc_bitsNeeded(length);
    if ( !cgc_readBits(pbs, pixel_index_length, &pixel_count) )
      goto LABEL_50;
    if ( !pixel_count )
    {
      cgc_printf("[ERROR] Empty frames not allowed\n");
      cgc_free(newFrame->image);
      newFrame->image = 0;
      cgc_free(newFrame);
      newFrame = 0;
      return 0;
    }
    pixel_count_bits = cgc_bitsNeeded(length - 1);
  }
  else
  {
    pixel_count = length;
  }
  if ( frame_type )
  {
    if ( !DWORD1073741823(pNewImage->renderedFrames[pNewImage->rCount]) )
    {
LABEL_50:
      cgc_free(newFrame->image);
      newFrame->image = 0;
      cgc_free(newFrame);
      newFrame = 0;
      return 0;
    }
    cgc_memcpy(newFrame->image, *(void **)(DWORD1073741823(pNewImage->renderedFrames[pNewImage->rCount]) + 8), length);
    for ( i = 0; i < pixel_count; ++i )
    {
      xbits = 0;
      ybits = 0;
      if ( !cgc_readBits(pbs, pixel_count_bits, &xbits) )
      {
        cgc_free(newFrame->image);
        newFrame->image = 0;
        cgc_free(newFrame);
        newFrame = 0;
        cgc_printf("[ERROR] Failed to read pixel index\n");
        return 0;
      }
      if ( !cgc_readBits(pbs, pixel_bits, &ybits) )
      {
        cgc_free(newFrame->image);
        newFrame->image = 0;
        cgc_free(newFrame);
        newFrame = 0;
        cgc_printf("[ERROR] Failed to read pixel value\n");
        return 0;
      }
      if ( length <= xbits )
      {
        cgc_printf("[ERROR] Index out of image bounds\n");
        cgc_free(newFrame->image);
        newFrame->image = 0;
        cgc_free(newFrame);
        newFrame = 0;
        return 0;
      }
      if ( dictionary->charCount <= ybits )
      {
        cgc_printf("[ERROR] Pixel beyond dictionary bounds\n");
        cgc_free(newFrame->image);
        newFrame->image = 0;
        cgc_free(newFrame);
        newFrame = 0;
        return 0;
      }
      newFrame->image[xbits] = dictionary->pixelArray[ybits];
    }
    xbits = -(((char)pixel_count * ((char)pixel_bits + (char)pixel_count_bits) + (char)pixel_index_length) & 7) & 7;
  }
  else
  {
    cgc_memset(newFrame->image, 32, length);
    for ( xbits = 0; xbits < pixel_count; ++xbits )
    {
      if ( !cgc_readBits(pbs, pixel_bits, &ybits) )
        goto LABEL_50;
      if ( dictionary->charCount < ybits )
      {
        cgc_printf("[ERROR] invalid pixel\n");
        cgc_free(newFrame->image);
        newFrame->image = 0;
        cgc_free(newFrame);
        newFrame = 0;
        return 0;
      }
      newFrame->image[xbits] = dictionary->pixelArray[ybits];
      ybits = 0;
    }
    xbits = -(pixel_bits * pixel_count) & 7;
  }
  if ( !xbits || cgc_readBits(pbs, xbits, &ybits) )
  {
    pNewImage->renderedFrames[pNewImage->rCount++] = newFrame;
    result = 1;
  }
  else
  {
    cgc_free(newFrame->image);
    newFrame->image = 0;
    cgc_free(newFrame);
    newFrame = 0;
    cgc_printf("[ERROR] Failed to read padding bits\n");
    result = 0;
  }
  return result;
}
// 281C: conditional instruction was optimized away because of '%pixel_dict.1==7'

// nfuncs=77 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
int  cgc_parseCVFFrame(
	void* mycgc_malloc,
	void* mycgc_free,
	void* mycgc_printf,
	void* mycgc_memcpy,
	void* mycgc_memset,
	void* mycgc_readBits,
	void* mycgc_bitsNeeded,
	pBitStream pbs,
	pcvf pNewImage
)
{

	int retValue;

	cgc_malloc = (pcgc_malloc) (mycgc_malloc);
	cgc_free = (pcgc_free) (mycgc_free);
	cgc_printf = (pcgc_printf) (mycgc_printf);
	cgc_memcpy = (pcgc_memcpy) (mycgc_memcpy);
	cgc_memset = (pcgc_memset) (mycgc_memset);
	cgc_readBits = (pcgc_readBits) (mycgc_readBits);
	cgc_bitsNeeded = (pcgc_bitsNeeded) (mycgc_bitsNeeded);

	__prd_init();
	retValue = mycgc_parseCVFFrame(
		pbs,
		pNewImage
	);

	__prd_exit();

	 /* ASM STACK HERE */

	return retValue;
}


void main()
{
	cgc_parseCVFFrame(
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		(pBitStream) NULL,
		(pcvf) NULL
	);
}
